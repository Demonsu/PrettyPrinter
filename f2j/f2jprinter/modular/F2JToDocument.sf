{-#
    INCLUDE "PrettyPrinterLib.sf"
    INCLUDE "PList.sf"
#-}

-- F2JType definition
-- NormalType: A[B,C]
-- PairedType: (A,B)
-- FunctionType: (A[D],C) -> B

data F2JType = F2JNormalType    String PList[F2JType]
             | F2JPairedType    PList[F2JType]
             | F2JFunctionType  F2JType F2JType
;

-- length of F2JNormalType

let lengF2JType (ftype: F2JType): Int=
	case ftype of
			F2JNormalType name types -> length(name)
		|	F2JPairedType types		 -> 4
		|	F2JFunctionType t1 t2    -> 4
;

-- F2JType to Document

let rec showF2JType (ftype: F2JType): Doc=
	case ftype of
			F2JNormalType name params -> 
			{
				case params of
					Nil 			  -> text name
				|	Cons x xs		  -> text name <> text "[" <> (showF2JTypes (x +> xs) ",") <> text "]"
				
			}
		|	F2JPairedType types		  -> text "(" <> (showF2JTypes types ",") <> text ")"
		|	F2JFunctionType from to   -> showF2JType from <> text " -> " <> showF2JType to
and
showF2JTypes (ftypelist: PList[F2JType]) (decollator: String): Doc =
	case ftypelist of
			Nil						  -> NIL
		|	Cons x xs				  -> 
			{
				case xs of
					Nil 			  -> showF2JType x
				|	Cons y ys 		  -> showF2JType x <> (text decollator) <> (showF2JTypes (y +> ys) decollator)
			}
;

-- F2JBindingParam definition

data F2JBindingParam = F2JBindingParam String F2JType
;

-- F2JBindingParam to Document

let rec showF2JBindingParam (fbindingparam: F2JBindingParam): Doc=
	case fbindingparam of
			F2JBindingParam name types ->
				text "(" <> text name <> text ": " <> showF2JType types <> text ")"
and showF2JBindingParams (fbindingparams: PList[F2JBindingParam]): Doc=
	case fbindingparams of
			Nil 					-> NIL
		|	Cons x xs				-> 
			{
				case xs of
					Nil 			-> showF2JBindingParam x
				|	Cons y ys		-> showF2JBindingParam x <> text " " <> showF2JBindingParams (y +> ys)
			}
;

-- F2JADTAlternative definition

data F2JADTAlternative = F2JADTAlternative String PList[F2JType]
;

-- F2JADTAlternative to Document

let rec showF2JADTAlternative (f2jadtalternative: F2JADTAlternative): Doc=
	case f2jadtalternative  of
			F2JADTAlternative name types	-> text "\t" <> text name <> text " " <> (showF2JTypes types " ")

and showF2JADTAlternatives (f2jadtalternatives: PList[F2JADTAlternative]) (indent: Int): Doc=
	case f2jadtalternatives of
			Nil 					-> NIL
		|	Cons x xs				->
			{
				case xs of
					Nil 			-> showF2JADTAlternative x
				|	Cons y ys 		-> showF2JADTAlternative x <> 
										line <>	text (space indent) <> text "|" <> (showF2JADTAlternatives (y +> ys) indent)
			}
;

-- F2JADTRecordItem definition

data F2JADTRecordItem = F2JADTRecordItem String F2JType
;

-- F2JADTRecordItem to Document

let rec showF2JADTRecordItem (f2jadtrecorditem: F2JADTRecordItem): Doc=
	case f2jadtrecorditem of
			F2JADTRecordItem name ty -> text "\t" <> text name <> text "\t\t: " <> showF2JType ty

and showF2JADTRecordItems (f2jadtrecorditems: PList[F2JADTRecordItem]): Doc=
	case f2jadtrecorditems of
			Nil 					 -> NIL
		|	Cons x xs				 -> 
			{
				case xs of
					Nil 			 -> showF2JADTRecordItem x
				|	Cons y ys		 -> showF2JADTRecordItem x <> text "," <> line <> showF2JADTRecordItems (y +> ys)
			}
;

-- F2JADTBody definition

data F2JADTBody = F2JADTNormalBody F2JType PList[F2JADTAlternative]
                | F2JADTRecordBody F2JType PList[F2JADTRecordItem]
;

-- F2JADTBody to document

let rec showF2JADTBody (f2jadtbody: F2JADTBody): Doc=
	case f2jadtbody of
			F2JADTNormalBody ftype alternatives		-> (showF2JType ftype) <> (text "= ") <> (showF2JADTAlternatives alternatives (lengF2JType(ftype) + 7)) <> line <> text ";"
		|	F2JADTRecordBody ftype recorditems		-> (showF2JType ftype) <> (text "= {") <> line <> (showF2JADTRecordItems recorditems) <> line <> text "}" <> line <> text ";"
 
and showF2JADTBodys (f2jadtbodys: PList[F2JADTBody]): Doc=
	case f2jadtbodys of
			Nil 				-> NIL
		|	Cons x xs 			->
			{
				case xs of
					Nil 		-> showF2JADTBody x
				|	Cons y ys	-> showF2JADTBody x <> line <> text "and" <> line <> showF2JADTBodys (y +> ys)
			}
;

-- Show definition
type Show[A] = A -> Doc;

-- Maybe definition

data Maybe[A] = Nothing
              | Just A
;

-- Maybe to Document
let showMaybe[A] (show: Show[A]) (mb: Maybe[A]): Doc=
	case mb of
			Nothing		-> NIL
		|	Just x 		-> show x
;


-- F2J definition
data rec
    F2JBindingBody = F2JLetBindingBody     String PList[F2JType] PList[F2JBindingParam] Maybe[F2JType] F2JExpr
                   | F2JLetRecBindingBody  String PList[F2JType] PList[F2JBindingParam] F2JType        F2JExpr
 
and F2JApplicationParam = F2JApplicationParamExpr F2JExpr
                        | F2JApplicationParamType PList[F2JType]

and F2JCaseAlternative = F2JCaseAlternative String PList[String] F2JExpr

and F2JRecordItem = F2JRecordItem String F2JExpr

            -- Application
and F2JExpr = F2JApplication        F2JExpr                  F2JApplicationParam
            -- Let binding                              ; expr
            | F2JLet                PList[F2JBindingBody]    F2JExpr
            -- Let rec binding                          ; expr
            | F2JLetRec             PList[F2JBindingBody]    F2JExpr
            -- Lambda function params                   inner expr
            | F2JLambda             PList[F2JBindingParam]   F2JExpr
            -- case of
            | F2JCase               F2JExpr                  PList[F2JCaseAlternative]
            -- ADT
            | F2JADT                PList[F2JADTBody]        F2JExpr
            | F2JRecADT             PList[F2JADTBody]        F2JExpr
            -- Alias
            | F2JTypeAlias          F2JType                  F2JType                     F2JExpr
            -- Tuple
            | F2JPair               PList[F2JExpr]
            -- Int literal
            | F2JIntLiteral         String
            -- Double literal
            -- Long literal
            -- Short literal
            -- Byte literal
            -- String Literal
            | F2JStringLiteral      String
            | F2JVariable           String
            | F2JBlock              PList[F2JExpr]
            | F2JRecord             PList[F2JRecordItem]
; 

-- F2JRecordItems to Document
let rec showF2JRecordItem (record: F2JRecordItem): Doc=
	line <> text "-- F2JRecordItem is TODO" <> line

and showF2JRecordItems (records: PList[F2JRecordItem]): Doc=
	line <> text "-- F2JRecordItems is TODO" <> line

;

-- F2J to Document
let rec showPListString (ss: PList[String]): Doc=
	case ss of
			Nil 		-> NIL
		|	Cons x xs	-> text x <> text " " <> showPListString xs
;

let rec showF2JBindingBody (b : F2JBindingBody): Doc =
    case b of
        	F2JLetBindingBody name args params rettype expr 	->
            	text name <> text "[" <> showF2JTypes args "," <> text "] " <> showF2JBindingParams params <> text ": " <> showMaybe[F2JType] showF2JType rettype <> text " =\n" <> showF2JExpr expr
     	|  	F2JLetRecBindingBody name args params rettype expr 	->
     			text name <> text "[" <> showF2JTypes args "," <> text "] " <> showF2JBindingParams params <> text ": " <> showF2JType rettype <> text " =\n" <> showF2JExpr expr


and showF2JBindingBodys (bs: PList[F2JBindingBody]): Doc=
	case bs of
			Nil 						-> NIL
		|	Cons x xs					->
			{
				case xs of
					Nil 				-> showF2JBindingBody x
				|	Cons y ys			-> showF2JBindingBody x <> line <> text "and" <> line <> showF2JBindingBodys (y +> ys) 
			}


-- TODO: Application can not be parsed now
and showF2JApplicationParam (ap: F2JApplicationParam): Doc=
	case ap of
			F2JApplicationParamExpr expr 	->
				showF2JExpr expr
		|	F2JApplicationParamType types	->
				showF2JTypes types " "

-- TODO: Length of CaseAlternative, replace nest 12
and showF2JCaseAlternative (ca: F2JCaseAlternative): Doc=
	case ca of
			F2JCaseAlternative dataname params expr 		->
				text "\t" <> text dataname <> text " " <> showPListString params <> text "\t\t" <> text "->" <> (nest 12 (line <> showF2JExpr expr)) 

and showF2JCaseAlternatives (cas: PList[F2JCaseAlternative]): Doc=
	case cas of
			Nil 						-> NIL
		|	Cons x xs					->
			{
				case xs of
					Nil 				-> showF2JCaseAlternative x
				|	Cons y ys 			-> showF2JCaseAlternative x <> line <> text "|" <> showF2JCaseAlternatives (y +> ys)
			}
and showF2JExpr (expr: F2JExpr): Doc=
	case expr of
		-- Parser of application still not be done
			F2JApplication expr apparm 				-> showF2JExpr expr <> showF2JApplicationParam apparm
		|	F2JLet bindingbodys f2jexpr 			-> text "let " <> showF2JBindingBodys bindingbodys <> line <> text ";" <> line <> showF2JExpr f2jexpr
		-- TODO: text ";" or "and" depends on the next f2jexpr
		|	F2JLetRec bindingbodys f2jexpr 			-> text "let rec " <> showF2JBindingBodys bindingbodys <> line <> text ";" <> line <> showF2JExpr f2jexpr
		|	F2JLambda bindingparams f2jexpr 		-> text "\\" <> showF2JBindingParams bindingparams <> text " -> " <> showF2JExpr expr
		-- Note: f2jexpr here should not write too much code
		| 	F2JCase f2jexpr casealternatives  		-> text "case " <> showF2JExpr f2jexpr <> text " of" <> line <> showF2JCaseAlternatives casealternatives
		|	F2JADT f2jadtbodys f2jexpr 				-> text "Data " <> showF2JADTBodys f2jadtbodys <> line <> text ";" <> line <> showF2JExpr f2jexpr
		-- TODO: text ";" or "and" depends on the next f2jexpr
		| 	F2JRecADT f2jadtbodys f2jexpr 			-> text "Data " <> showF2JADTBodys f2jadtbodys <> line <> text ";" <> line <> showF2JExpr f2jexpr
		|	F2JTypeAlias type1 type2 f2jexpr 		-> text "type " <> showF2JType type1 <> text "= " <> showF2JType type2 <> showF2JExpr f2jexpr
		|	F2JPair exprs 							-> showF2JExprs exprs
		-- Easy job, I like it
		|	F2JIntLiteral s 						-> text s
		|	F2JStringLiteral s 						-> text s
		|	F2JVariable v 							-> text v
		-- Hard job, TAT
		|	F2JBlock exprs							-> line <> text "{" <> showF2JExprs exprs <> line <> text "}"
		|	F2JRecord recorditems 					-> showF2JRecordItems recorditems

and showF2JExprs (exprs: PList[F2JExpr]): Doc=
	-- Haha, we'll discuss it later
	text "--ExprList is TODO" <> line
;






