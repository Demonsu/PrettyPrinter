-- complete pretty printer library

data Doc =	NIL
        |	TEXT String
		|	LINE
		|	NEST Int Doc
		|	UNION Doc Doc
		|   CONCAT Doc Doc
;

data PDoc = NI
		|	TE String PDoc
		|	LI Int PDoc
;

let nil = NIL
;

-- union operation
let (<|>) (x: Doc) (y: Doc) : Doc =
	UNION x y
;


let text (s: String): Doc =
	TEXT s
;

let line: Doc = 
	LINE
;

-- union laws
let rec (<>) (x: Doc) (y: Doc) : Doc =
	CONCAT x y
;

let rec nest (i: Int) (x: Doc): Doc =
	NEST i x
;

-- kill all the line, replace with sapce

let rec flatten (d: Doc): Doc =
	case d of
			NIL 			-> NIL
		|	LINE 			-> TEXT " "
		|	TEXT s 			-> TEXT s 
		|	UNION x y		-> flatten x
		|	CONCAT x y 		-> (flatten x) <> (flatten y)
;

-- new api for user, tell lib where you want minimum line nums

let rec group (d: Doc): Doc =
	(flatten d) <|> d
;

-- judge whther the doc fit the line width

let rec fits (w: Int) (d: Doc): Bool=
	if w < 0 then False
	else 
		case d of
				NIL 			-> True
			|	TEXT s  		-> fits (w - s.length()) NIL
			|	LINE 	  		-> True
			|	UNION _  _		-> False
			|	CONCAT _ _ 		-> False
;

-- return a better one, here better means max width within limit 

let better (w: Int) (k: Int) (x: Doc) (y: Doc): Doc =
	if fits (w - k) x then x
	else  y
;

-- return the best layout among groups

let rec best (w: Int) (k: Int) (d: Doc): PDoc =
	case d of
			NIL 			-> NIL
		|	LINE i x 		-> LINE i (best w k x)
		|	TEXT s x 		-> TEXT s (best w (k + s.length()) x)
		|	UNION x y 		-> better w k (best w k x) (best w k y)
;


let concat (x : String) (y : String): String= 
	x.concat(y)
;

let rec space (i: Int): String=
	if i==0 then
				""
			 else
			 	" ".concat(space (i-1))
;

let rec showDoc(doc: PDoc): String=
	case doc of
			TE s x	-> concat s (showDoc x)
		|	LI i d 	-> concat (concat "\n" (space i)) (showDoc d)
		| 	NI			-> ""
;

let pretty (w: Int) (d: Doc): String =
	showDoc (best w 0 d)
;

